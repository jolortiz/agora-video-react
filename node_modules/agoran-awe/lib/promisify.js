"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** ==== promisify client ==== */
exports.promisifyClient = function (methodName, options) {
    var target = options.target, thisArg = options.thisArg, argumentList = options.argumentList;
    switch (methodName) {
        default:
            return Reflect.apply(target, thisArg, argumentList);
        case 'init':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, argumentList.slice(0, 1).concat([resolve, reject]));
            });
        case 'join':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, argumentList.slice(0, 3).concat([resolve, reject]));
            });
        case 'leave':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'publish':
            return new Promise(function (resolve, reject) {
                setTimeout(resolve);
                Reflect.apply(target, thisArg, argumentList.slice(0, 1).concat([reject]));
            });
        case 'subscribe':
            return new Promise(function (resolve, reject) {
                setTimeout(resolve);
                Reflect.apply(target, thisArg, argumentList.slice(0, 2).concat([reject]));
            });
        case 'unpublish':
            return new Promise(function (resolve, reject) {
                setTimeout(resolve);
                Reflect.apply(target, thisArg, argumentList.slice(0, 1).concat([reject]));
            });
        case 'unsubscribe':
            return new Promise(function (resolve, reject) {
                setTimeout(resolve);
                Reflect.apply(target, thisArg, argumentList.slice(0, 1).concat([reject]));
            });
        case 'enableDualStream':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getCameras':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getLocalAudioStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getLocalVideoStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getNetworkStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getPlayoutDevices':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getRecordingDevices':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getRemoteAudioStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getRemoteVideoStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getSystemStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getTransportStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
    }
};
exports.promisifyStream = function (methodName, options) {
    var target = options.target, thisArg = options.thisArg, argumentList = options.argumentList;
    switch (methodName) {
        default:
            return Reflect.apply(target, thisArg, argumentList);
        case 'init':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
        case 'getStats':
            return new Promise(function (resolve, reject) {
                Reflect.apply(target, thisArg, [resolve, reject]);
            });
    }
};
